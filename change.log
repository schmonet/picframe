2024-05-24
----------

- **Erstellung von `test/test_bulk_video_player.py`:**
  - Ein neues Python-Skript wurde entwickelt, um die Videowiedergabe systematisch zu testen und die Performance verschiedener Video-Dateien zu bewerten.
  - Das Skript findet alle Videos im Verzeichnis `test/videos/`, spielt sie mit `mpv` ab und sammelt detaillierte Logs.
  - Metadaten wie Codec, Auflösung und Dauer werden mit `ffprobe` ausgelesen.
  - Die Ergebnisse werden in einer übersichtlichen Markdown-Tabelle zusammengefasst, die Metriken wie effektive FPS, Laufzeit und Fehlerdetails enthält.

- **Fehlerbehebung und Verfeinerung von `test_bulk_video_player.py`:**
  - Implementierung der Auslesung der Display-Bildwiederholrate aus `/sys/kernel/debug/dri/0/state`, was die Notwendigkeit von `sudo`-Rechten mit sich brachte.
  - Behebung eines Problems, bei dem `mpv` unter `sudo` den GPU-Kontext nicht initialisieren konnte.
  - Untersuchung und Lösung von Performance-Problemen, die durch verschiedene `mpv`-Parameter (`--vo=drm`, `--hwdec=auto`) und Umgebungsvariablen (`DISPLAY=:0`) verursacht wurden.
  - Nach mehreren Iterationen wurde die Komplexität reduziert. Die finale, stabile Lösung erfordert, das Skript direkt mit `sudo` auszuführen und `mpv` mit minimalen Parametern aufzurufen, damit es die optimale Konfiguration für die Hardware-Beschleunigung selbstständig finden kann.

- **Dokumentation:**
  - `Readme.md` wurde um eine Beschreibung von `test_bulk_video_player.py` und `test_bulk_video_player.log` erweitert.
  - Diese `change.log`-Datei wurde erstellt, um die jüngsten Entwicklungen zu dokumentieren.

  2025-10-10
- Enhanced `scripts/check_pic_dates.sh` to support video files (`mkv`, `mp4`, etc.).
- The script now reads creation date metadata from video containers using `exiftool`, in addition to image EXIF data.
- Refactored `scripts/sync_photos.sh` to support separate storage quotas for photos and videos within a single cache.
- Introduced a unified cache directory in `scripts/sync_config.yaml` to ensure compatibility with `picframe`.
- The sync script now calculates storage usage per media type to enforce quotas.
- Removed all automatic cache cleanup logic from the sync script to allow the cache to be filled continuously.

2025-09-30:
- Corrected aspect ratio calculation in `viewer_display.py` to prevent horizontal stretching of portrait images.
- Replaced incorrect aspect ratio logic in `viewer_display.py`.

2025-10-01:
- Corrected the calculation of start and end points for vertical panning in `viewer_display.py`.
- Corrected the conversion of pixel offset to shader uniform offset in `viewer_display.py`.

2025-10-02:
- Refactored `__calculate_kenburns_transform` in `viewer_display.py` to add a slight zoom for portrait images and randomize zoom and pan for landscape images.

2025-10-03:
- Modified `viewer_display.py` to calculate pan/wobble range based on display dimensions.
- Corrected the pannable area calculation in `viewer_display.py` to prevent black borders.
- Split `kenburns_wobble_pct` into `kenburns_landscape_wobble_pct` and `kenburns_portrait_wobble_pct`.
- Corrected a `SyntaxError` in `viewer_display.py`.

2025-10-04:
- Corrected `AttributeError` in `viewer_display.py` by initializing and using new wobble parameters.
- Fixed inconsistent Ken Burns effect for landscape images by enforcing a minimum zoom in `viewer_display.py`.
- Corrected script path in `install.sh` to reflect new directory structure.
- Provided guidance on fixing `FileNotFoundError` for config file by updating `watcher.sh`.
- Provided guidance on fixing shell script errors by converting line endings with `dos2unix`.

2025-10-05:
- Created a new shell script `check_pic_dates.sh` to check and correct image dates based on directory names and EXIF data.
- Added `libimage-exiftool-perl` to `install.sh` to provide `exiftool`.
- Corrected the clock's vertical position calculation in `viewer_display.py`.
- Fixed a bug in `check_pic_dates.sh` that caused an invalid date format for the `touch` command.
- Added an 'A' (All) option to `check_pic_dates.sh` to process all directories without further prompts.
- Fixed a syntax error (`;&&`) in `check_pic_dates.sh`.
- Fixed a corrupted `while` loop in `check_pic_dates.sh` that caused a syntax error.

2025-10-14
- Modified `scripts/pir_manager.py` to start `picframe` immediately if motion is detected during the night-off period.
- This overrides the night schedule for the current cycle, preventing the system from turning off again until the next night.
- Added a `night_override` flag to manage this state.
- Fixed a bug where the '~' in `CONFIG_PATH` was not expanded, by using `os.path.expanduser()`.

2025-10-18
- Added `scripts/create_test_images.sh` to generate test images by converting PNGs to JPGs.
- The script overlays image metadata (dimensions, color space) onto the image and adds randomized EXIF data.
- Iteratively debugged the script to handle shell syntax errors and system locale differences for number formatting.
- Enhanced the script to differentiate between portrait and landscape images, adjusting text size and position accordingly.
- Modified the text overlay to use a bold font for better readability.
- Finalized `scripts/create_test_images.sh` by adjusting text position and style for portrait images, including larger text and a refined outline for better visibility.

2025-10-28
- Modified install.sh to copy 99-fb-blank.rules and reload udev rules.
- Modified viewer_display.py to handle video playback by restarting the application.
- Created viewer_process.py to display a single image.
- Simplified controller.py by moving video logic to viewer_display.py.
- Refactored video_player.py to use a direct shell command for VLC.
- Updated video_streamer.py to manage the new video_player.py subprocess.
- Enhanced test_image_video_player.py to blank the screen during transitions.
- Created test_show_image.py for the image/video player test.
- Updated test_video_player.py to align with the latest video playback mechanism.

## 2025-10-31

- **test/test_integrated_video.py**:
  - Modified `pi3d.Texture` creation to use 3D numpy arrays instead of 2D to match the expected shape.
  - Reshaped Y, U, and V planes to be 3D arrays before assigning them to the textures.
  - (Reverted) Removed `i_format` argument from `pi3d.Texture` calls to let `pi3d` infer the format.
  - (Reverted) Removed the unused import for `pi3d.constants`.
  - (Reverted) Added import for `pi3d.constants` and changed `pi3d.GL_RED` to `constants.GL_RED`.
  - (Reverted) Changed `pi3d.Texture` calls to use `i_format=pi3d.GL_RED`.
- **README.md**:
  - Added "Video Support Development Status" section with a table summarizing the attempts to implement video playback.

## 2025-10-30

- **src/picframe/video_streamer.py**:
  - Experimented with different `ffmpeg` command line options for video decoding.
  - (Reverted) Added `-c:v h264_v4l2m2m` for hardware decoding.
  - (Reverted) Changed pixel format to `rgb24`.
  - Set pixel format to `yuv420p` to match the video's native format.

2025-10-31:
- Continued ffmpeg integration for video playback.
- Modified test_integrated_video.py to fix numpy array shape mismatch for pi3d textures (from 2D to 3D).
- Investigated and documented different approaches for video support in README.md.

2025-10-30:
- Continued with ffmpeg integration for video playback.
- In test_integrated_video.py, tried using pi3d.constants.GL_RED for single channel textures.

2025-10-29:
- Started implementation of video playback via ffmpeg frame streaming.
- Created test_integrated_video.py to test the integration.
- In test_integrated_video.py, tried using i_format=pi3d.GL_LUMINANCE for textures.

Date: 2025-11-09

- A recurring bug occurs during the alternating playback of videos and images on the target system (Pi Zero 2W).
- A crash with the error message: AssertionError: There was an empty texture in your Buffer.
- After a code modification to address the crash, a white screen is displayed instead of the next image after a video finishes.
- The core problem lies in the transition from video playback back to pi3d-based image display.
- Video playback appears to interfere with the graphics context (OpenGL), causing the texture for the subsequent image to be loaded incorrectly or deemed invalid.
- Previous fix attempts to repair the texture loading/assignment logic in viewer_display.py only cycled between the two error states.
- Proposed Solution: Decouple video playback completely from the pi3d loop.
- The approach is modeled after the stable test script test/test_image_video_player.py:
- The pi3d display is cleanly shut down before the video.
- The video is played using an external, blocking player (cvlc).
- After the video ends, pi3d is completely re-initialized for the next image display.
- This method avoids conflicts with the graphics context and ensures the image display starts in a clean state after a video.
- Added a summary table to TASKS.md to track different approaches for video playback.
- Investigated the circular error of 'empty texture' and 'white screen' after video playback.
- The current plan is to re-implement video playback by stopping pi3d, playing the video with an external player, and then re-initializing pi3d, similar to `test/test_image_video_player.py`. This is to avoid a full service restart.

2023-11-12
- src/picframe/controller.py - Refactored `loop()` to ensure `self.__viewer.slideshow_is_running()` is called only once per iteration.
- Effect: Addressed potential race condition causing `AssertionError` or white screen after video playback by preventing redundant calls to `slideshow_is_running` within a single loop cycle.
- src/picframe/viewer_display.py - Moved `self.__slide.set_textures()` call to immediately follow the assignment of `self.__sfg` and `self.__sbg` within `slideshow_is_running()`.
- Effect: Ensured that the `pi3d.Sprite` object (`self.__slide`) receives the new texture data as soon as it's loaded, preventing `AssertionError` due to drawing with an empty texture.
- src/picframe/viewer_display.py - Modified `slideshow_is_running()` to set `self.__alpha = 1.0` when `self.__sfg` is `None` (i.e., after video playback).
- Effect: Addressed white screen issue by forcing the display of the foreground texture in the first frame after `pi3d` re-initialization, bypassing potential issues with background texture activation.
- src/picframe/controller.py - Simplified `loop()` logic by removing the `if/else` block around the `slideshow_is_running` call.
- Effect: Streamlined the controller's interaction with the viewer, aiming to prevent race conditions and `AssertionError` by ensuring a consistent single call to the display update method.

2023-11-13
  - src/picframe/controller.py - Corrected indentation of the `else` block in `loop()` and repositioned `self.__force_navigate = False`.
  - Effect: Fixed `IndentationError` preventing the program from starting.
  - src/picframe/controller.py - Removed redundant `self.__force_navigate = False` assignment within the `if is_video:` block.
  - Effect: Cleaned up redundant code, improving clarity and reducing potential for subtle logic errors.
  - src/picframe/viewer_display.py - Modified `slideshow_is_running()` to include a `new_image_loaded` flag and extended the safeguard condition to `if self.__sfg is None or new_image_loaded:`.
  - Effect: Introduced a robust safeguard to explicitly skip the `draw()` call for one frame immediately after a new image is loaded or `pi3d` is re-initialized, giving the graphics engine time to prepare textures and preventing `AssertionError` or white screen.

2023-11-14
  - src/picframe/viewer_display.py - Refined the safeguard logic in `slideshow_is_running()` by introducing `self.__first_draw_after_init` flag.
  - Effect: Ensures that `pi3d` has at least one full frame to process texture assignments after re-initialization, preventing `AssertionError` by avoiding `draw()` calls on unready textures.
  - Refactored video playback logic for improved stability and architectural clarity.
  - `controller.py`: Simplified the main loop's video handling. After `play_video_blocking` returns, the controller no longer forces a loop restart (`continue`). Instead, it sets the current picture to `None` and lets the loop proceed, delegating state management entirely to the viewer.
  - `viewer_display.py`: Implemented a "self-healing" mechanism within `play_video_blocking`. This method now encapsulates the entire video playback cycle: cleanly stopping `pi3d` (`slideshow_stop`), playing the video via an external process, and then fully re-initializing the `pi3d` display (`slideshow_start`).
  - `viewer_display.py`: Added an explicit screen clear (`self.__display.clear()` and `self.__display.swap_buffers()`) after `pi3d` re-initialization to ensure a clean black screen transition and prevent visual artifacts from the previous graphics context.
  - `viewer_display.py`: Simplified the safeguard in `slideshow_is_running` to `if self.__sfg is None:`. This robustly prevents drawing operations when no texture is ready (i.e., in the first frame after a video), thus avoiding `AssertionError` and white screens.
  - Reverted video playback mechanism.
  - Abandoned in-process pi3d re-initialization after numerous attempts resulted in `AssertionError` or a white screen. This indicates a fundamental synchronization issue between texture loading and drawing after the graphics context is destroyed and recreated.
  - Reverted to the stable method of exiting the picframe application after video playback. The external `watcher.sh` service is now responsible for restarting the application.
  - `controller.py`: Main loop now breaks after a video is played, triggering a clean shutdown.
  - `viewer_display.py`: `play_video_blocking` method was simplified to `play_video`, which now only stops pi3d and plays the video, without attempting to re-initialize the display.

2023-11-15 - Finalized robust video playback and album resume logic.
  - Implemented a stable restart-after-video mechanism using a watcher script.
  - `controller.py`: Now exits with a special code (10) after video playback, signaling the watcher to restart.
  - `watcher.sh`: A new wrapper script that runs `picframe` in a loop, restarting it only when it exits with code 10.
  - `start.py`: Now handles the exit code returned from the controller.
  - `model.py`:
      - Completely overhauled the album and file selection logic to support seamless resuming.
      - Uses `~/picframe/shown_albums.log` to track both completed albums and the next file to be played.
      - On startup, it now correctly reads the resume-file from the log and sets the internal file index to continue playback at the exact right spot.
      - Fixed a critical bug where `__file_index` was always reset to 0, which caused the endless loop.
      - The logic to save the resume state now correctly identifies the file *after* the current one.
  - `image_cache.py`:
      - Added robust error handling to prevent crashes when `ffprobe` fails or returns empty metadata for a video.
      - Fixed a `NameError` by correctly importing `get_video_info`.
      - Fixed an `AttributeError` by correctly parsing the dictionary returned from `get_video_info`.
  - `get_image_meta.py`:
      - Re-introduced the `get_video_info` function to extract metadata from videos using `ffprobe`.
  - `requirements.txt` & `install.sh`:
      - Added `exifread` as a dependency to fix a `ModuleNotFoundError`.
      - Consolidated installation logic into `install.sh`.
  - Numerous minor bug fixes related to `AttributeError` and `IndentationError` during the implementation of the resume logic.

## 2025-11-18

### feat: Robuste Video-Übergänge und komplettes Installations-Skript

- **feat(viewer_display):** Implementierung einer robusten Methode zum Schwärzen des Bildschirms während Video-Übergängen.
  - Verwendet `dd if=/dev/zero of=/dev/fb0`, um die Konsole vor und nach der Videowiedergabe zuverlässig auszublenden.
  - Eine `WARNING` im Log (`dd ... returned non-zero exit status 1`) wird als "Feature" akzeptiert, da der gewünschte visuelle Effekt (schwarzer Bildschirm) erzielt wird.

- **feat(install):** Erstellung eines umfassenden `install.sh`-Skripts zur Automatisierung der gesamten Systemeinrichtung.
  - Installiert alle Systemabhängigkeiten (python, mpv, cec-utils, etc.).
  - Fügt den Benutzer zur `video`-Gruppe hinzu, um den Zugriff auf Framebuffer und CEC zu gewährleisten.
  - Deaktiviert den blinkenden Konsolen-Cursor über die Kernel-Kommandozeile (`/boot/firmware/cmdline.txt`) für saubere Übergänge.
  - Richtet den `picframe.service` für `systemd` ein.
  - Konfiguriert die `cron`-Jobs für `sync_photos.sh` und `pir_manager.py`.

- **refactor(interface_peripherals):** Der Mauszeiger wird nun direkt in `pi3d` deaktiviert (`show_pointer=False`), was zuverlässiger ist als externe Skripte.


## 2025-11-17

### fix: Stabilität der Videowiedergabe und Fehlerbehebung

- **fix(watcher):** Das Neustart-Signal für Videos wird nun über eine Umgebungsvariable (`PICFRAME_RESTART_CODE`) anstatt eines Kommandozeilen-Arguments übergeben.
  - Behebt den Fehler `picframe: error: unrecognized arguments: 10`.
  - Vereinfacht das `watcher.sh`-Skript erheblich.

- **refactor(viewer_display):** Radikale Vereinfachung der `play_video`-Methode.
  - Alle instabilen Versuche, den Bildschirm manuell zu färben (z.B. mit `dd` und temporären Dateien oder direktem Schreiben in den Framebuffer), wurden entfernt.
  - Dies behebt diverse Fehler wie `[Errno 28] No space left on device` und `BrokenPipeError`.

- **chore(troubleshooting):** Systematische Untersuchung und Dokumentation verschiedener Methoden zur Bildschirmsteuerung.
  - **Versuch 1-7 (Fehlgeschlagen):** Diverse `dd`- und Python-basierte Ansätze zum Färben des Framebuffers führten zu Fehlern (`BrokenPipe`, `No space left on device`, `KeyError`).
  - **Versuch 8 (Stabil):** Entfernung aller manuellen Bildschirmsteuerungen. Ergebnis: Stabile Funktion, aber sichtbare Konsole beim Übergang.
  - **Versuch 9 (Fehlgeschlagen):** Einsatz von `setterm` zur Färbung der Konsole. Funktionierte zunächst, war aber nach einem System-Neustart instabil.
  - **Versuch 11 (Erfolgreich):** Gezielter Einsatz von `dd if=/dev/zero` als finale Lösung (siehe 2025-11-18).

  ### 30. November 2023

**Ziel: Stabile Video-Integration als Frame-Sequenz (Alternative zu mpv)**

*   **Versuch 1: Direkte Integration in `ImageCache`**
    *   **Änderung:** `image_cache.py` wurde angepasst, um Videos zu erkennen und Metadaten mit `ffprobe` zu extrahieren.
    *   **Ergebnis:** Fehlgeschlagen. `picframe` stürzte beim Start mit `CRITICAL: Failed to create pi3d display` ab.
    *   **Grund:** Der `subprocess`-Aufruf von `ffprobe` im `ImageCache`-Thread verursachte eine Race Condition mit der `pi3d`-Initialisierung.

*   **Versuch 2: "Just-in-Time" Frame-Extraktion**
    *   **Änderung:** Die Video-Logik wurde von `image_cache.py` in `viewer_display.py` verschoben, um Frames erst bei Bedarf zu extrahieren.
    *   **Ergebnis:** Fehlgeschlagen. Der `pi3d`-Startkonflikt blieb bestehen.
    *   **Grund:** Allein der `import subprocess` zur Ladezeit in `viewer_display.py` reichte aus, um die `pi3d`-Initialisierung zu stören.

*   **Versuch 3: Vollständige Bereinigung und Neustrukturierung**
    *   **Änderung:** Mehrere Versuche, alle Video-bezogenen Änderungen aus `image_cache.py`, `controller.py`, `viewer_display.py`, `get_image_meta.py` und `start.py` zu entfernen, um einen stabilen Zustand wiederherzustellen.
    *   **Ergebnis:** Fehlgeschlagen. Es traten weiterhin verschiedene `AttributeError` beim `pi3d`-Start auf (`... has no attribute 'context'` oder `... has no attribute 'display'`).
    *   **Grund:** Eine Kaskade von subtilen Problemen:
        1.  Übersehene Code-Reste (z.B. ein hartcodiertes `use_sdl2 = False`).
        2.  Falsche Startreihenfolge in `start.py`, bei der das `Model` vor dem `Viewer` initialisiert wurde.
        3.  Import-Zeit-Konflikte, bei denen das Laden von Modulen wie `model` oder `viewer_display` (die wiederum `subprocess` oder `threading` importierten) den `pi3d`-Start störte.

*   **Strategiewechsel: Externer Vorverarbeitungsprozess**
    *   **Änderung:** Die Erkenntnis, dass jede Form von `subprocess`-Aufruf innerhalb des `picframe`-Prozesses instabil ist, führte zu einem neuen Plan.
    *   **Dokumentation:** Die neue Strategie (externes Skript `video_preprocessor.py`) und die Chronik der Fehlversuche wurden in `README.md` dokumentiert.
    *   **Ergebnis:** Dies ist der aktuelle, vielversprechende Plan für die weitere Entwicklung.

*   **Versuch 5: Radikale Bereinigung und Isolation**
    *   **Änderung:** Um Import-Konflikte zu lösen, wurde die `DEFAULT_CONFIG` in eine eigene, "saubere" Datei `default_config.py` ausgelagert. `start.py` wurde angepasst, um nur noch diese Datei und `viewer_display.py` zu importieren, bevor das Display erstellt wird. Der Import des `model`-Moduls wurde so weit wie möglich nach hinten verschoben.
    *   **Ergebnis:** Fehlgeschlagen. Der Fehler `CRITICAL: Failed to create pi3d display: 'DisplayOpenGL' object has no attribute 'display'` blieb bestehen.
    *   **Grund:** Die letzte verbleibende Ursache wurde identifiziert: Der `import subprocess` an der Spitze von `viewer_display.py` "vergiftete" die Umgebung für `pi3d` bereits beim Laden des Moduls.

*   **Versuch 6: Später Import von `subprocess`**
    *   **Änderung:** Der `import subprocess` wurde aus dem globalen Scope von `viewer_display.py` entfernt und stattdessen direkt in die Methoden verschoben, die ihn benötigen.
    *   **Ergebnis:** Fehlgeschlagen. Keine Änderung am Fehlerbild.
    *   **Grund:** An diesem Punkt wurde klar, dass die Kette von Abhängigkeiten und Seiteneffekten bei der Initialisierung zu komplex und fragil ist, um sie innerhalb des `picframe`-Prozesses zuverlässig zu lösen.

*   **Strategiewechsel: Externer Vorverarbeitungsprozess**
    *   **Änderung:** Die Erkenntnis, dass jede Form von `subprocess`-Aufruf innerhalb des `picframe`-Prozesses instabil ist, führte zu einem neuen Plan.
    *   **Dokumentation:** Die neue Strategie (externes Skript `video_preprocessor.py`) und die Chronik der Fehlversuche wurden in `README.md` dokumentiert.
    *   **Ergebnis:** Dies ist der aktuelle, vielversprechende Plan für die weitere Entwicklung.

### 29. November 2023

**Ziel: Den `pi3d`-Startkonflikt umgehen**

*   **Versuch 3: "Just-in-Time" Frame-Extraktion**
    *   **Änderung:** Die Video-Logik wurde von `image_cache.py` in `viewer_display.py` verschoben. Die Idee war, Frames erst bei Bedarf zu extrahieren, lange nachdem `pi3d` initialisiert wurde.
    *   **Ergebnis:** Fehlgeschlagen. Der `pi3d`-Startkonflikt blieb bestehen.
    *   **Grund:** Es wurde erkannt, dass nicht nur der Aufruf von `subprocess`, sondern bereits der `import` des Moduls zur Ladezeit des Programms den Konflikt auslöst.

*   **Versuch 4: Optimierung der Startreihenfolge**
    *   **Änderung:** `start.py` wurde grundlegend umgebaut, um `pi3d.Display.create()` als allerersten Schritt auszuführen, noch vor dem Logging und der Erstellung des `Model`-Objekts.
    *   **Ergebnis:** Fehlgeschlagen. Es traten weiterhin verschiedene `AttributeError` beim `pi3d`-Start auf (`... has no attribute 'context'` oder `... has no attribute 'display'`).
    *   **Grund:** Eine Kaskade von subtilen Problemen wurde aufgedeckt:
        1.  Übersehene Code-Reste (z.B. ein hartcodiertes `use_sdl2 = False`).
        2.  Import-Zeit-Konflikte, bei denen das Laden von Modulen wie `model` oder `viewer_display` (die wiederum `subprocess` oder `threading` importierten) den `pi3d`-Start störte.

### 28. November 2023 (und früher)

**Ziel: Stabile Video-Integration als Frame-Sequenz (Alternative zu mpv)**

*   **Versuch 1: Direkte Integration in `ImageCache`**
    *   **Änderung:** `image_cache.py` wurde angepasst, um Videos zu erkennen und Metadaten (Dauer, Auflösung) mit `ffprobe` zu extrahieren.
    *   **Ergebnis:** Fehlgeschlagen. `picframe` stürzte beim Start mit `CRITICAL: Failed to create pi3d display` ab.
    *   **Grund:** Der `subprocess`-Aufruf von `ffprobe` im `ImageCache`-Thread verursachte eine Race Condition mit der `pi3d`-Initialisierung.

*   **Versuch 2: Manuelle Konfigurationsanpassungen**
    *   **Änderung:** Diverse Anpassungen in der `configuration.yaml`, um `use_sdl2` und andere Grafik-Parameter zu testen.
    *   **Ergebnis:** Fehlgeschlagen. Keine dieser Änderungen konnte den fundamentalen Konflikt zwischen `subprocess` und `pi3d` beim Start beheben.
