# Gemini Context File for picframe

## üéØ Projekt Goals
* PictureFrame with pi3d: [https://github.com/helgeerbe/picframe/tree/main](https://github.com/helgeerbe/picframe/tree/main) (Python environment)
    * Slideshow uses Pi3D directly on the framebuffer
    * Smooth cross-fading transition with separately adjustable delay for transition and display time
    * Permanent display of the time
    * Display of the album directory name **{Location}** and year directory name **{YYYY}** as well as any existing EXIF data of the respective photo
    * Playback of photos and videos from a local, limited image cache on the SD card
* Remote access for maintenance, configuration, and updates
    * SSH Shell
    * WebUI
* Interfaces
    * Bluetooth of the Pi Zero 2 WH is permanently deactivated
    * WLAN of the Pi Zero 2 WH is deactivated at night between 11:00 PM and 6:00 AM

## üõ†Ô∏è Tech-Stack
* Raspberry Pi Zero 2 WH
* 64 GB SD card for image cache, OS, and software
* Full-HD display
* Wooden picture frame, Maple
* PIR Motion Sensor HC-SR501 PIR
* Raspberry Pi OS Bookworm Lite (64-bit)
* Without desktop environment (headless, no Wayland/X11)

## üìú Rules

* for all conversation with the user, stay in german language, while all source code, logs and documentation shall be in english language
* update `change.log`, `README.md` and `TODO.md` only on User Request
* when updating `change.log` group all changes and effects of a whole day by date only and add new lines, do not delete existing history
* only commit changes to the users repo on Gitlab on explezit user request

## ‚ùå Known Issues

* After Videoplayback using mpv player, when a image is following, the image is presented as a full white screen. Alternatively, when this shader issue was resolved and the image is shown, picframe crashes on some error for some reason. 
* Ken Burns needs fine tuning regarding zoom factor on the end of the effect. It was observed, that when Landscape Ken Burns ends and next image starts, zoom factor was more that 1.0 which results in cropping of some part of the image. Allthough no exact fullscreen zoom is required, it should be close to 1.0

## üß† Current Status

* First Video/Image whitescreen/error-issue needs to be fixed.
* Then Ken Burns end zoom i.e. image to large issue should be fixed.

## Files, Readme and Changelog üõ†Ô∏è

* `picframe/change.log` contains all **changes** to `picframe` and to added files, with the date and time of the change, grouped by days.
* `picframe/picframe.log` current log of `picframe` service status, to check for errors and warnings.
* `picframe/README.md` Github Readme from original Repo explaining the basic functionality plus additional features as provided in the fork.
* `picframe/TODO.md` Comprehensive functional description to be updated continuously

### Picframe Source Code üõ†Ô∏è

* `picframe/src/picframe/` contains all python scripts from to original repo, many of the changed to implement required extensions and changes

### Configuration Files üõ†Ô∏è

* `picframe/scripts/sync_config.yaml` containes parameter values for frequency of sync and download of pictures and videos from a given SMB share on the local network
* `picframe/configuration.yaml` containes all parameter values from to original repo, with a few added to control required extensions and changes

### System Scripts, Installer and Service-Setup üõ†Ô∏è

* `picframe/scripts/watcher.sh` is a **wrapper for picframe**; it starts `picframe` as a service after boot and runs in the background.
* `picframe/scripts/install.sh` **installs** all necessary packages and files required for Python, picframe, and additional shell scripts. `install.sh` also writes the necessary file for the `picframe` Linux service and writes the crontab entries. However, it does not create the shell scripts themselves.
* `picframe/scripts/pir_manager.py` checks PIR sensor for movement every few minutes and controls slideshow and standby of the screen depending on presence of motion
* `picframe/scripts/sync_photos.sh` downloads fotos randomly folder-wise according to parameter settings in `sync_config.yaml`

### Testing Scripts and content üõ†Ô∏è

* `picframe/scripts/check_pic_dates.sh` compares file access date and exif creaton date of images with folder name `<yyyy>` and sets to year of folder if required
* `picframe/scripts/create_test_images.sh` convert existing PNGs to JPGs and add fake exif metadata including geo-reference
* `picframe/scripts/test_pir.py` test proper detection of PIR sensor on a given pin of the PI header
* `picframe/test/test/videos` extened set of multi purpose test videos to test playback capabilities with different resolutions, aspect ratio, codecs, bitrates including color test patterns
* `picframe/test/test/images` extened set of multi purpose test images to test Ken Burns and display capabilities with different resolutions, aspect ratio including color test patterns
* `picframe/test/test/test_image_video_player.py` script to test both video and image playback in an alterating sequence

---

## Extensions

* Extension of the `picframe` Python environment for additional functions
    * `group_by_dir: true` shows all photos from the same folder before moving to a new folder. If `shuffle: true` is set, only images within the same folder are shown randomly. Otherwise, the sorting specified by `sort_cols` is used.
    * `shuffle: False` is adjusted depending on `group_by_dir`.
    * `delete_after_show: true` each photo is permanently deleted immediately after it is shown to free up SD storage space and prevent multiple displays
    * The path of each shown album from `picframe_cache` is written to `shown_albums.log`.
    * Display format $/ge$ image format 16:9 $/ge$ 13:9 $/ge$ 4:3 $/ge$ 5:4,
* Extension of the Ken Burns effect, if `kenburns: true`
    * NO (image change only starts after scrolling/zoom ends) - Ken Burns to the next image already starts during the cross-fade
    * **All:** Independent of image format
        * NO (Fixed point always top left) - if `kenburns_random_pan: true` random sideways drift for each image, random $/le$ `kenburns_wobble_pct`
        * If `kenburns_random_pan: false` centered zoom without sideways drift
    * **Landscape:** If *image width $/ge$ height*
        * If `kenburns_zoom_direction: random` randomly for each image
            * `zoom: in` starts screen-filling
                * YES - Image is magnified
            * NO (starts screen-filling) - `zoom: out` starts oversized
                * Image is reduced
            * Zoom always follows percentage random $/le$ `kenburns_zoom_pct`
        * If `kenburns_zoom_direction: in, out` same for each image
            * Corresponding to `zoom: in` or `zoom: out`
            * Zoom percentage random = `kenburns_zoom_pct`
    * **Portrait:** If *image width $/le$ height*
        * NO (multiple images side by side) - Scrolling starts with image width scaled exactly to display width, image aspect ratio is maintained.
        * If `kenburns_scroll_direction: random` randomly for each image
            * YES - `scroll: top down` or `scroll: bottom up`
            * NO - vertical scrolling starts and ends with a random offset $/le$ `kenburns_portrait_border_pct`
        * If `kenburns_scroll_direction: up, down` same for each image
            * Corresponding to `scroll: down = top down` or `scroll: up = bottom up`
            * Vertical scrolling starts and ends with a random offset $/le$ `kenburns_portrait_border_pct`

### Video Option 1: Full Video Playback with `mpv` (Default)

Stable playback of entire video files is achieved through a controlled restart of the application:

*   **Detection:** `picframe` determines that the next file in the playlist is a video.
*   **Set Bookmark:** It saves the path of the *next* image file (the one that should come after the video) to the state file `shown_albums.log`.
*   **Play Video:** The external player `mpv` is started and plays the video in full-screen mode.
*   **Exit with Signal:** After the video, `picframe` exits itself with the special **Exit Code 10**.
*   **Restart by Watcher:** The `watcher.sh` script, which monitors `picframe`, detects exit code 10 and immediately restarts the application. All other exit codes would terminate the service.
*   **Resumption:** On restart, `picframe` reads the bookmark from `shown_albums.log`, finds the corresponding file in the playlist, and resumes the slideshow exactly at that point.

### Video Option 2: Video Slideshow with `ffmpeg` (Alternative)

This method treats videos not as movies, but as a sequence of still images that are seamlessly blended into the slideshow. This completely avoids application restarts.

*   **External Preprocessing:** A separate, external script runs in the background.
*   **Find Videos:** This script scans the image directories for video files.
*   **Extract Frames:** For each new video, it uses `ffmpeg` to extract individual frames at regular intervals (e.g., every 10 seconds).
*   **Save as Images:** The extracted frames are saved as standard `.jpg` files in a dedicated subfolder.
*   **Seamless Integration:** The extracted frames are treated like normal photos and are integrated into the regular slideshow with cross-fading effects, but excluding Ken Burns.

---

### Automatic Slideshow during the day üìÖ

* Slideshow and display are deactivated at night between **12:00 AM and 6:00 AM**.
* Detect with **PIR sensor RCW-0506** whether people are nearby.
* `pir_manager.py` checks PIR sensor for movement every 15 minutes:
    * **HOLD** (1h no movement): the slideshow is **paused**; as soon as movement is detected again, the slideshow resumes.
    * **PAUSED** (3h no movement): the slideshow is **paused** and the screen **turns black**. As soon as movement is detected again, it continues with the next image.
    * **OFF** (Night mode is activated between 12 AM and 6 AM): the `picframe` service is **terminated** and `kmsblank` is activated for 7 hours. **WLAN is off**. At 6 AM, the `picframe` service starts with a new album.

---

### Local Image Cache on SD card üñºÔ∏è

* Photos already shown are automatically **deleted** from the SD card by `picframe`.
* **Random or sequential playback** of photos within an album `{Location}` from the local cache `picframe_cache`
* **Random or sequential selection** of albums from different years `{YYYY}` from the local cache `picframe_cache`

---

### Photo Synchronization from Home Server (SMB) üíæ

* `sync_photos.sh` runs **in the background** alongside the `picframe` service.
* Started regularly via **cron job**: synchronization from Windows photo share from server on the LAN via **SMB**.
* **Hourly check** during the day whether server share or IP is reachable only when WLAN is active.
* If the server is reachable: **automatic download** of photo albums until the cache is full.
* Directory structure of images on the server: `//{serverip}/{PhotoShare}/{YYYY}/{Location}`
    * Each album is assigned to a directory named `{Location}`.
    * Automatic download of albums/directories, each **randomly selected** for `{Location}` and `{YYYY}`.
    * Photo filenames usually follow `{YYYYMMDD_HHMMSS}{arbitrary suffix}.jpg` and may contain special characters, as far as allowed in the NTFS file system.
    * The **date and time stamp** of the files is transferred when copying from the server to `picframe_cache`.
* Maximum number of pictures per album is fixedly adjustable (`maxPicsPerAlbum`): if there are more photos in an album, e.g., only every 2nd, 3rd, or 10th photo in alphabetical order (ascending) is downloaded to the cache to avoid exceeding `maxPicsPerAlbum`.
* Cleaning up/deleting **empty folders** in `picframe_cache`.
* `sync_photos.sh` only fetches folders from the server that are **not noted** in `shown_albums.log`.

---
